BorderedMorph subclass: #APlayer	instanceVariableNames: 'name cardPack openCards'	classVariableNames: ''	poolDictionaries: ''	category: 'Card-Game'!!APlayer methodsFor: 'game-morph' stamp: 'NS 3/7/2023 16:47'!gameParameters	| thisStageParam aMessage cardHeight cardWidth |								cardHeight := (ImageCard new initialize: 1) height.	cardWidth := (ImageCard new initialize: 1) width.	aMessage := name , ' : ' , ((cardPack checkSize) asString) , ' cards left to play'.		thisStageParam := TextMorph new contents: aMessage ;wrapFlag: true; yourself.	thisStageParam extent: (3 * cardWidth)@cardHeight.	thisStageParam wrapCentering: #center.	thisStageParam backgroundColor: Color black.	thisStageParam color: Color white.		^thisStageParam.! !!APlayer methodsFor: 'game-morph' stamp: 'NS 3/4/2023 19:09'!gameStage	| thisGameStage cardHeight cardWidth |								cardWidth := (ImageCard new initialize: 1) width.	cardHeight := (ImageCard new initialize: 1) height.		thisGameStage := Morph new layoutPolicy: TableLayout new.	thisGameStage extent: (3 * cardWidth)@cardHeight.	thisGameStage borderColor: Color gray.	thisGameStage wrapCentering: #center.	thisGameStage listCentering: #topLeft.	thisGameStage listDirection: #rightToLeft.	thisGameStage addMorph: (openCards at: 1).	thisGameStage addMorph: (openCards at: 2).	thisGameStage addMorph: (openCards at: 3).		^thisGameStage.! !!APlayer methodsFor: 'game-morph' stamp: 'NS 3/7/2023 15:37'!newStage	self addMorph: (self gameParameters).	self addMorph: (self gameStage).	! !!APlayer methodsFor: 'game-morph' stamp: 'NS 3/4/2023 19:37'!open3Cards	|cardX cardY cardZ pack |		openCards := Array new: 3.		cardX := cardPack takeCard.	cardY := cardPack takeCard.	cardZ := cardPack takeCard.		openCards := Array new: 3.	openCards at: 1 put: (cardX); at:2 put: (cardY); at: 3 put: (cardZ).	self removeAllMorphs.	self newStage.			pack := CardsPack new initialize.	pack addCard:cardX.	pack addCard:cardY.	pack addCard:cardZ.		^pack.! !!APlayer methodsFor: 'game-morph' stamp: 'NS 3/7/2023 17:13'!openCard	openCards := Array new: 3.	openCards at: 1 put: (FinishCard new initialize); at: 2 put: (cardPack takeCard); at: 3 put: (FinishCard new initialize).	self removeAllMorphs.	self newStage.			^(openCards at: 2).! !!APlayer methodsFor: 'getPlayerParam' stamp: 'NS 3/4/2023 19:41'!getCards: aPack	cardPack merge: aPack.! !!APlayer methodsFor: 'getPlayerParam' stamp: 'NS 3/7/2023 17:12'!numOfCards	^cardPack checkSize! !!APlayer methodsFor: 'getPlayerParam' stamp: 'NS 3/4/2023 19:22'!playerName	^name.! !!APlayer methodsFor: 'initialize-release' stamp: 'NS 3/7/2023 16:36'!initialize: aCardsStack name: playerName	| cardWidth cardHeight |		cardWidth := (ImageCard new initialize: 1) width.	cardHeight := (ImageCard new initialize: 1) height.		super initialize.		cardPack := aCardsStack.	name := playerName.	openCards := Array new: 3.	openCards at: 1 put: (FinishCard new initialize); at: 2 put: (FinishCard new initialize); at: 3 put: (FinishCard new initialize).			self extent: (3 * cardWidth)@(2 * cardHeight).	self layoutPolicy: TableLayout new.	self listDirection: #topToBottom.	self listCentering: #topLeft.	self wrapCentering: #center.	self vResizing: #spaceFill.	self hResizing: #spaceFill.	self color: Color gray.	self borderWidth: 3.	self borderColor: Color green.		self newStage.! !Object subclass: #CardsPack	instanceVariableNames: 'cardsPack'	classVariableNames: ''	poolDictionaries: ''	category: 'Card-Game'!!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/3/2023 22:16'!addCard: aCard	cardsPack add: aCard.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/7/2023 16:55'!biggerThan: aPack		|onePackvalues towPackValues|	onePackvalues := SortedCollection new sortBlock: [:x :y | x > y].	towPackValues := SortedCollection new sortBlock: [:x :y | x > y].		1 to: (self checkSize) do: [ :i |		onePackvalues add: (cardsPack at: i) value.		towPackValues add: ((aPack cards) at: i) value.	].	1 to: (self checkSize) do: [ :i |		((onePackvalues at: i) > (towPackValues at: i)) ifTrue: [			^true.		].		((onePackvalues at: i) < (towPackValues at: i)) ifTrue: [			^false.		].	].	^false.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/3/2023 22:18'!cards	^cardsPack.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/3/2023 22:19'!checkSize	^(cardsPack size).! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/4/2023 11:13'!initialize	cardsPack := OrderedCollection new.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/4/2023 11:18'!merge: aPack	|cardsToMerge|	cardsToMerge := (aPack cards) select: [:card | card value > -1].	cardsPack := cardsPack union: cardsToMerge.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/4/2023 11:19'!shuffle	cardsPack := cardsPack shuffled.! !!CardsPack methodsFor: 'as yet unclassified' stamp: 'NS 3/7/2023 17:04'!takeCard	|card|	(self checkSize = 0) ifTrue: [ ^ FinishCard new initialize.].	card := cardsPack atRandom.	cardsPack remove: card.	^card.! !ImageMorph subclass: #ImageCard	instanceVariableNames: 'value cardHeight cardWidth'	classVariableNames: ''	poolDictionaries: ''	category: 'Card-Game'!!ImageCard methodsFor: 'as yet unclassified' stamp: 'NS 3/7/2023 19:34'!initialize: cardNum	|picturInFolder picNum|	picturInFolder := 'c:\mmn16-cardWarGame\cardsPic\'.		super initialize.	value := cardNum rem: 13.	picNum := (cardNum asString) , '.png'.	self image: (ImageReadWriter formFromFileNamed: (picturInFolder ,picNum)).! !!ImageCard methodsFor: 'as yet unclassified' stamp: 'NS 3/3/2023 21:49'!value	^value.! !ImageCard subclass: #FinishCard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Card-Game'!!FinishCard methodsFor: 'as yet unclassified' stamp: 'NS 3/7/2023 19:34'!initialize	| picFolder |	picFolder := 'c:\mmn16-cardWarGame\cardsPic\'.		super initialize.	self image: (ImageReadWriter formFromFileNamed: (picFolder ,'blanckCard.png')).! !!FinishCard methodsFor: 'as yet unclassified' stamp: 'NS 3/7/2023 15:56'!value	^-1.! !BorderedMorph subclass: #WarCardsGame	instanceVariableNames: 'groupPlayers'	classVariableNames: ''	poolDictionaries: ''	category: 'Card-Game'!!WarCardsGame methodsFor: 'result' stamp: 'NS 3/7/2023 18:22'!printAWinner	| winner runNewGame |		runNewGame := nil.		1 to: (groupPlayers size) do: [ :i |		((groupPlayers at:i) numOfCards = 52) ifTrue:[			winner := groupPlayers at:i.			UIManager default inform: 'End Game - The winner is: ' , winner name.].		].				[runNewGame ~= 'y' and: runNewGame ~= 'n'] whileTrue:[		runNewGame := UIManager default request: 'Would you like to run another game? [y/n]'.].	(runNewGame = 'y') ifTrue:[		self removeAllMorphs.		self initialize.		^runNewGame = 'y'.	].	^runNewGame = 'n'.	! !!WarCardsGame methodsFor: 'result' stamp: 'NS 3/4/2023 14:51'!winnerFound	1 to: (groupPlayers size) do:[ :i |		((groupPlayers at: i) numOfCards = 52) ifTrue: [			^true.		].	].	^false.! !!WarCardsGame methodsFor: 'playGame' stamp: 'NS 3/7/2023 18:10'!startGame	| thisPack bigestCard thisCard winner winners game|	game := true.	[game] whileTrue:[		[(self winnerFound) not] whileTrue: [			thisPack := CardsPack new.			winners := Set new.			bigestCard := FinishCard new.						1 to: (groupPlayers size) do: [ :i |				( (groupPlayers at: i) numOfCards > 0) ifTrue:[					thisCard := (groupPlayers at: i) openCard. 					(thisCard value > -1) ifTrue:[						thisPack addCard: thisCard.					].						(thisCard value = bigestCard value) ifTrue: [						"Same value as the highest.. maybe theyll get in a war.."						winners add: (groupPlayers at: i).					].					(thisCard value > bigestCard value) ifTrue: [						"Highest we've seen. dump all previous winners"						winners := Set new.						winners add: (groupPlayers at: i).						bigestCard := thisCard.					].												]				ifFalse:[					"This player has no more cards.. just make sure the graphics show it by opening an empty card"					(groupPlayers at: i) openCard.				].			].			World doOneCycle.			2 seconds asDelay wait.			(winners size > 1) ifTrue: [				"War"				winner := self warPlayers: winners cardsToWin: thisPack.			]			ifFalse: [				winner := winners atRandom.			].			winner getCards: thisPack.		].		game := self printAWinner.		].! !!WarCardsGame methodsFor: 'playGame' stamp: 'NS 3/7/2023 18:06'!warPlayers: warPlayers cardsToWin: thisPack	| tempWinners bigestLastCard this3cards thisWarPlayer |		tempWinners := warPlayers.		[tempWinners size > 1] whileTrue: [		bigestLastCard := CardsPack new.		bigestLastCard addCard: FinishCard new.		bigestLastCard addCard: FinishCard new.		bigestLastCard addCard: FinishCard new.		thisWarPlayer := tempWinners.				tempWinners := Set new.						thisWarPlayer do: [ :player |			this3cards := player open3Cards.			thisPack merge: this3cards.			(this3cards biggerThan: bigestLastCard) ifTrue: [				tempWinners := Set new.				tempWinners add: player.				bigestLastCard := this3cards.			]			ifFalse:[				((bigestLastCard biggerThan: this3cards) not) ifTrue: [					tempWinners add: player.				].			].									].		World doOneCycle.		1 seconds asDelay wait.	].	^tempWinners atRandom.! !!WarCardsGame methodsFor: 'initialization' stamp: 'NS 3/7/2023 19:13'!initialize	| allPackCards thisPlayerPack deafultStartPlayer playersNum cardsNumPlayer namesList|		super initialize.		namesList := (UIManager default request: ('please enter players names seperated by commas' , String cr, 'ie: name1,name2..', String cr, 'for this cards war game')) asString.	playersNum := (namesList subStrings: ',') size.		deafultStartPlayer := APlayer new initialize:(CardsPack new initialize) name:'deafult'.		self position: 10@10.	self extent: (deafultStartPlayer width) * 4 @ deafultStartPlayer height.	self layoutPolicy: TableLayout new.	self listDirection: #rightToLeft.	self listCentering: #topLeft.	self wrapCentering: #center.	self borderWidth: 0.	self color: Color gray.	self openInWorld.		allPackCards := CardsPack new initialize.	0 to: 51 do: [ :cardNum |		allPackCards addCard: (ImageCard new initialize: cardNum)	].	allPackCards shuffle.	cardsNumPlayer := (52 / playersNum) floor.		groupPlayers := OrderedCollection new: playersNum.	1 to: playersNum do: [ :i |		thisPlayerPack := CardsPack new initialize.		cardsNumPlayer timesRepeat: [			thisPlayerPack addCard: (allPackCards takeCard)		].		groupPlayers add: (APlayer new initialize: thisPlayerPack name:((namesList subStrings: ',') at: i)).	].	(playersNum = 3) ifTrue: [		(groupPlayers first) getCards: allPackCards.	].	1 to: playersNum do: [ :i |		self addMorph: (groupPlayers at: i).	]! !